"""A printer for human-readable output in error messages etc."""

import collections
import dataclasses
import re
import typing

from typing import Iterable, List

from pytype import matcher
from pytype.abstract import abstract
from pytype.abstract import abstract_utils
from pytype.abstract import function
from pytype.overlays import typed_dict as typed_dict_overlay
from pytype.pytd import escape
from pytype.pytd import optimize
from pytype.pytd import pytd
from pytype.pytd import pytd_utils
from pytype.pytd import visitors
from pytype.typegraph import cfg


@dataclasses.dataclass
class BadReturn:
  expected: str
  bad_actual: str
  full_actual: str
  error_details: List[str]


@dataclasses.dataclass
class BadCall:
  expected: str
  actual: str
  error_details: List[str]


def show_constant(val: abstract.BaseValue) -> str:
  """Pretty-print a value if it is a constant.

  Recurses into a constant, printing the underlying Python value for constants
  and just using "..." for everything else (e.g., Variables). This is useful for
  generating clear error messages that show the exact values related to an error
  while preventing implementation details from leaking into the message.

  Args:
    val: an abstract value.

  Returns:
    A string of the pretty-printed constant.
  """
  def _ellipsis_printer(v):
    if isinstance(v, abstract.PythonConstant):
      return v.str_of_constant(_ellipsis_printer)
    return "..."
  return _ellipsis_printer(val)


def print_pytd(pytd_type: pytd.Type) -> str:
  """Print the name of the pytd type."""
  typ = pytd_utils.CanonicalOrdering(
      optimize.Optimize(
          pytd_type.Visit(visitors.RemoveUnknownClasses())))
  name = pytd_utils.Print(typ)
  # Clean up autogenerated namedtuple names, e.g. "namedtuple-X-a-_0-c"
  # becomes just "X", by extracting out just the type name.
  if "namedtuple" in name:
    return escape.unpack_namedtuple(name)
  nested_class_match = re.search(r"_(?:\w+)_DOT_", name)
  if nested_class_match:
    # Pytype doesn't have true support for nested classes. Instead, for
    #   class Foo:
    #     class Bar: ...
    # it outputs:
    #   class _Foo_DOT_Bar: ...
    #   class Foo:
    #     Bar = ...  # type: Type[_Foo_DOT_Bar]
    # Replace _Foo_DOT_Bar with Foo.Bar in error messages for readability.
    # TODO(b/35138984): Get rid of this hack.
    start = nested_class_match.start()
    return name[:start] + name[start+1:].replace("_DOT_", ".")
  return name


class PrettyPrinter:
  """Pretty print types for errors."""

  def join_printed_types(self, types: Iterable[str]) -> str:
    """Pretty-print the union of the printed types."""
    types = set(types)  # dedup
    if len(types) == 1:
      return next(iter(types))
    elif types:
      literal_contents = set()
      optional = False
      new_types = []
      for t in types:
        if t.startswith("Literal["):
          literal_contents.update(t[len("Literal["):-1].split(", "))
        elif t == "None":
          optional = True
        else:
          new_types.append(t)
      if literal_contents:
        literal = f"Literal[{', '.join(sorted(literal_contents))}]"
        new_types.append(literal)
      if len(new_types) > 1:
        out = f"Union[{', '.join(sorted(new_types))}]"
      else:
        out = new_types[0]
      if optional:
        out = f"Optional[{out}]"
      return out
    else:
      return "nothing"

  def print_as_generic_type(self, t) -> str:
    convert = t.ctx.pytd_convert
    generic = pytd_utils.MakeClassOrContainerType(
        t.get_instance_type().base_type,
        t.formal_type_parameters.keys(),
        False)
    with convert.set_output_mode(convert.OutputMode.DETAILED):
      return print_pytd(generic)

  def print_as_expected_type(self, t: abstract.BaseValue, instance=None) -> str:
    """Print abstract value t as a pytd type."""
    convert = t.ctx.pytd_convert
    if isinstance(t, (abstract.Unknown, abstract.Unsolvable,
                      abstract.Class)) or t.is_late_annotation():
      with convert.set_output_mode(convert.OutputMode.DETAILED):
        return print_pytd(t.get_instance_type(instance=instance))
    elif isinstance(t, abstract.Union):
      return self.join_printed_types(
          self.print_as_expected_type(o) for o in t.options)
    elif t.is_concrete:
      typ = typing.cast(abstract.PythonConstant, t)
      return re.sub(
          r"(\\n|\s)+", " ",
          typ.str_of_constant(self.print_as_expected_type))
    elif (isinstance(t, (abstract.AnnotationClass, abstract.Singleton)) or
          t.cls == t):
      return t.name
    else:
      return f"<instance of {self.print_as_expected_type(t.cls, t)}>"

  def print_as_actual_type(self, t, literal=False) -> str:
    convert = t.ctx.pytd_convert
    if literal:
      output_mode = convert.OutputMode.LITERAL
    else:
      output_mode = convert.OutputMode.DETAILED
    with convert.set_output_mode(output_mode):
      return print_pytd(t.to_type())

  def print_as_function_def(self, fn: abstract.Function) -> str:
    convert = fn.ctx.pytd_convert
    name = fn.name.rsplit(".", 1)[-1]  # We want `def bar()` not `def Foo.bar()`
    with convert.set_output_mode(convert.OutputMode.DETAILED):
      pytd_def = convert.value_to_pytd_def(fn.ctx.root_node, fn, name)
    return pytd_utils.Print(pytd_def)

  def print_pytd_signature(self, sig: pytd.Signature) -> str:
    return print_pytd(sig)

  def print_error_details(
      self, error_details: matcher.ErrorDetails
  ) -> List[str]:
    # Re-export this for convenience, since a lot of other error types include
    # matcher errors in their details.
    return MatcherErrorPrinter(self).print_error_details(error_details)

  def print_var_as_type(self, var: cfg.Variable, node: cfg.CFGNode) -> str:
    """Print a pytype variable as a type."""
    if not var.bindings:
      return "nothing"
    convert = var.data[0].ctx.pytd_convert
    with convert.set_output_mode(convert.OutputMode.DETAILED):
      typ = pytd_utils.JoinTypes(
          b.data.to_type()
          for b in abstract_utils.expand_type_parameter_instances(var.bindings)
          if node.HasCombination([b]))
    return print_pytd(typ)

  def show_variable(self, var: cfg.Variable) -> str:
    """Show variable as 'name: typ' or 'pyval: typ' if available."""
    if not var.data:
      return print_pytd(pytd.NothingType())
    val = var.data[0]
    name = val.ctx.vm.get_var_name(var)
    typ = self.join_printed_types(
        self.print_as_actual_type(t) for t in var.data)
    if name:
      return f"'{name}: {typ}'"
    elif len(var.data) == 1 and hasattr(val, "pyval"):
      name = show_constant(val)
      return f"'{name}: {typ}'"
    else:
      return f"'{typ}'"


class BadCallPrinter:
  """Print the details of an abstract.function.BadCall."""

  def __init__(self, pp: PrettyPrinter, bad_call: function.BadCall):
    self.bad_call = bad_call
    self._pp = pp

  def _iter_sig(self):
    """Iterate through a function.Signature object. Focus on a bad parameter."""
    sig = self.bad_call.sig
    for name in sig.posonly_params:
      yield "", name
    if sig.posonly_params:
      yield ("/", "")
    for name in sig.param_names[sig.posonly_count:]:
      yield "", name
    if sig.varargs_name is not None:
      yield "*", sig.varargs_name
    elif sig.kwonly_params:
      yield ("*", "")
    for name in sorted(sig.kwonly_params):
      yield "", name
    if sig.kwargs_name is not None:
      yield "**", sig.kwargs_name

  def _iter_expected(self):
    """Yield the prefix, name and type information for expected parameters."""
    bad_param = self.bad_call.bad_param
    sig = self.bad_call.sig
    for prefix, name in self._iter_sig():
      suffix = " = ..." if name in sig.defaults else ""
      if bad_param and name == bad_param.name:
        type_str = self._pp.print_as_expected_type(bad_param.typ)
        suffix = ": " + type_str + suffix
      yield prefix, name, suffix

  def _iter_actual(self, literal):
    """Yield the prefix, name and type information for actual parameters."""
    # We want to display the passed_args in the order they're defined in the
    # signature, unless there are starargs or starstarargs.
    # Map param names to their position in the list, then sort the list of
    # passed args so it's in the same order as the params.
    sig = self.bad_call.sig
    passed_args = self.bad_call.passed_args
    bad_param = self.bad_call.bad_param
    keys = {param: n for n, (_, param) in enumerate(self._iter_sig())}
    def key_f(arg):
      arg_name = arg[0]
      # starargs are given anonymous names, which won't be found in the sig.
      # Instead, use the same name as the varags param itself, if present.
      if arg_name not in keys and pytd_utils.ANON_PARAM.match(arg_name):
        return keys.get(sig.varargs_name, len(keys)+1)
      return keys.get(arg_name, len(keys)+1)
    for name, arg in sorted(passed_args, key=key_f):
      if bad_param and name == bad_param.name:
        suffix = ": " + self._pp.print_as_actual_type(arg, literal=literal)
      else:
        suffix = ""
      yield "", name, suffix

  def _print_args(self, arg_iter):
    """Pretty-print a list of arguments. Focus on a bad parameter."""
    # (foo, bar, broken : type, ...)
    bad_param = self.bad_call.bad_param
    printed_params = []
    found = False
    for prefix, name, suffix in arg_iter:
      if bad_param and name == bad_param.name:
        printed_params.append(prefix + name + suffix)
        found = True
      elif found:
        printed_params.append("...")
        break
      elif pytd_utils.ANON_PARAM.match(name):
        printed_params.append(prefix + "_")
      else:
        printed_params.append(prefix + name)
    return ", ".join(printed_params)

  def print_call_details(self):
    bad_param = self.bad_call.bad_param
    expected = self._print_args(self._iter_expected())
    literal = "Literal[" in expected
    actual = self._print_args(self._iter_actual(literal))
    if bad_param and bad_param.error_details:
      details = self._pp.print_error_details(bad_param.error_details)
    else:
      details = []
    return BadCall(expected, actual, details)


class MatcherErrorPrinter:
  """Pretty printer for some specific matcher error types."""

  def __init__(self, pp: PrettyPrinter):
    self._pp = pp

  def _print_protocol_error(self, error: matcher.ProtocolError) -> str:
    """Pretty-print the protocol error."""
    convert = error.left_type.ctx.pytd_convert
    with convert.set_output_mode(convert.OutputMode.DETAILED):
      left = print_pytd(error.left_type.get_instance_type())
      protocol = print_pytd(error.other_type.get_instance_type())
    if isinstance(error, matcher.ProtocolMissingAttributesError):
      missing = ", ".join(sorted(error.missing))
      return (f"Attributes of protocol {protocol} are not implemented on "
              f"{left}: {missing}")
    else:
      assert isinstance(error, matcher.ProtocolTypeError)
      actual, expected = error.actual_type, error.expected_type
      if (isinstance(actual, abstract.Function) and
          isinstance(expected, abstract.Function)):
        # TODO(b/196434939): When matching a protocol like Sequence[int] the
        # protocol name will be Sequence[int] but the method signatures will be
        # displayed as f(self: Sequence[_T], ...).
        actual = self._pp.print_as_function_def(actual)
        expected = self._pp.print_as_function_def(expected)
        return (f"\nMethod {error.attribute_name} of protocol {protocol} has "
                f"the wrong signature in {left}:\n\n"
                f">> {protocol} expects:\n{expected}\n\n"
                f">> {left} defines:\n{actual}")
      else:
        with convert.set_output_mode(convert.OutputMode.DETAILED):
          actual = print_pytd(error.actual_type.to_type())
          expected = print_pytd(error.expected_type.to_type())
        return (f"Attribute {error.attribute_name} of protocol {protocol} has "
                f"wrong type in {left}: expected {expected}, got {actual}")

  def _print_noniterable_str_error(self, error) -> str:
    """Pretty-print the matcher.NonIterableStrError instance."""
    return (
        f"Note: {error.left_type.name} does not match string iterables by "
        "default. Learn more: https://github.com/google/pytype/blob/main/docs/faq.md#why-doesnt-str-match-against-string-iterables")

  def _print_typed_dict_error(self, error) -> str:
    """Pretty-print the matcher.TypedDictError instance."""
    ret = ""
    if error.missing:
      ret += "\nTypedDict missing keys: " + ", ".join(error.missing)
    if error.extra:
      ret += "\nTypedDict extra keys: " + ", ".join(error.extra)
    if error.bad:
      ret += "\nTypedDict type errors: "
      for k, bad in error.bad:
        for match in bad:
          actual = self._pp.print_as_actual_type(match.actual_binding.data)
          expected = self._pp.print_as_expected_type(match.expected.typ)
          ret += f"\n  {{'{k}': ...}}: expected {expected}, got {actual}"
    return ret

  def print_error_details(
      self, error_details: matcher.ErrorDetails
  ) -> List[str]:
    printers = [
        (error_details.protocol, self._print_protocol_error),
        (error_details.noniterable_str, self._print_noniterable_str_error),
        (error_details.typed_dict, self._print_typed_dict_error)
    ]
    return ["\n" + printer(err) if err else "" for err, printer in printers]

  def prepare_errorlog_details(
      self, bad: List[matcher.BadMatch]
  ) -> List[str]:
    """Prepare printable annotation matching errors."""
    details = collections.defaultdict(set)
    for match in bad:
      d = self.print_error_details(match.error_details)
      for i, detail in enumerate(d):
        if detail:
          details[i].add(detail)
    ret = []
    for i in sorted(details.keys()):
      ret.extend(sorted(details[i]))
    return ret

  def print_return_types(
      self, node: cfg.CFGNode, bad: List[matcher.BadMatch]
  ) -> BadReturn:
    """Print the actual and expected values for a return type."""
    formal = bad[0].expected.typ
    convert = formal.ctx.pytd_convert
    with convert.set_output_mode(convert.OutputMode.DETAILED):
      expected = print_pytd(formal.get_instance_type(node))
      if isinstance(formal, typed_dict_overlay.TypedDictClass):
        expected = expected + "(TypedDict)"
    if "Literal[" in expected:
      output_mode = convert.OutputMode.LITERAL
    else:
      output_mode = convert.OutputMode.DETAILED
    with convert.set_output_mode(output_mode):
      bad_actual = print_pytd(pytd_utils.JoinTypes(
          match.actual_binding.data.to_type(node, view=match.view)
          for match in bad))
      actual = bad[0].actual
      if len(actual.bindings) > len(bad):
        full_actual = print_pytd(pytd_utils.JoinTypes(
            v.to_type(node) for v in actual.data))
      else:
        full_actual = bad_actual
    # typing.Never is a prettier alias for nothing.
    fmt = lambda ret: "Never" if ret == "nothing" else ret
    error_details = self.prepare_errorlog_details(bad)
    return BadReturn(
        fmt(expected), fmt(bad_actual), fmt(full_actual), error_details
    )
